1. 下面代码的问题：
func funcMui(x,y int) (sum int,error){
      x+y,nil
}

解析：第二返回值没有命名。

-----------------------------------------------------------------------------------------------

2.new()和make()的区别

解析：
new(T) 和 make(T,args) 是 Go 语言内建函数，用来分配内存，但适用的类型不同。

new(T) 会为 T 类型的新值分配已置零的内存空间，并返回地址（指针），即类型为 *T 的值。换句话说就是，
返回一个指针，该指针指向新分配的、类型为 T 的零值。适用于值类型，如数组、结构体等。

make(T,args) 返回初始化之后的 T 类型的值，这个值并不是 T 类型的零值，也不是指针 *T，
是经过初始化之后的 T 的引用。make() 只适用于 slice、map 和 channel.

-----------------------------------------------------------------------------------------------

3.通过指针变量 p 访问其他成员变量 name，有哪几种方式？
A. p.name B.(&p).name C.(*p).name D. p->name

解析：AC，&取址运算符，*指针解引用

-----------------------------------------------------------------------------------------------

4.关于字符串连接，下面说法正确的是？
A. str:= 'abc'+'123'  B. str := "abc" + "123"  C. srt := 'abc'+ "123"  D. fmt.Sprintf("abc%d",123)

//解析：BD

-----------------------------------------------------------------------------------------------

5.下面代码是否编译通过？
const（
      x = iota
      -
      y
      z = "zz"
      k
      p = iota
      )

func main(){
      fmt.Println(x,y,z,k,p)
}

//解析： 编译通过，输出：0 2 zz zz 5

-----------------------------------------------------------------------------------------------

6.下面赋值正确的是：
A. var x = nil  B. var x interface{} = nil  C. var x string = nil  D. var x error = nil

//解析：BD  nil值只能赋值给指针、chan、func、interface、map、slice


-----------------------------------------------------------------------------------------------

7. 关于init函数，下面说法正确的是：
A. 一个包中，可以包含多个init函数
B. 程序编译时，先执行依赖包的inti函数，再执行main包内的init函数
C. main包中，不能有init函数
D. inti函数可以被其他函数调用

//解析：AB

-----------------------------------------------------------------------------------------------

8. 关于channel，下面语法正确的是：
A. var ch chan int
B. ch := make(chan int)
C. <-ch
D. ch<-

//解析：ABC

-----------------------------------------------------------------------------------------------

9. 关于cap()函数的使用类型，下面说法正确的是：
A. array   B. slice  C. map   D. channel

//解析：ABD


-----------------------------------------------------------------------------------------------

10. 下面属于关键字的是：

A. func  B. struct   C. class   D. defer

//解析：ABD

-----------------------------------------------------------------------------------------------


11. 定义一个包内全局字符串变量，下面语法正确的是：

A. var str string   B. str := ""  C. str = ""   D. var str = ""

//解析： AD    B只能局部变量声明，C是赋值

-----------------------------------------------------------------------------------------------


12. 以下代码输出什么：
func main（）{
     i := 5
     defer printfunc(i)
     i = i + 10
}

func printfunc(i int){
    fmt.println(i)
}

//解析： defer语句会保存一份副本，也就是5.

-----------------------------------------------------------------------------------------------

13.以下代码输出什么：

func main() {
    str := "hello"
    str[0] = 'x'
    fmt.Println(str)
}

A. hello    B. xello   C. compilation error

//解析：C  常量，go语言中的字符串是只读的

-----------------------------------------------------------------------------------------------


14.下面代码输出什么？

func incr(p *int) int {
    *p++
    return *p
}

func main() {
    p :=1
    incr(&p)
    fmt.Println(p)
}
A. 1   B. 2    C. 3


//解析： B   指针，incr()函数里的p是*int类型的指针，指向的main()函数的变量p的地址。第2行代码是将改地址的值执行一个自增操作，
//incr()返回自增后的结果

-----------------------------------------------------------------------------------------------


15.对 add() 函数调用正确的是（）

func add(args ...int) int {

    sum := 0
    for _, arg := range args {
        sum += arg
    }
    return sum
}
A. add(1, 2)   B. add(1, 3, 7)  C. add([]int{1, 2})  D. add([]int{1, 3, 7}…)

//解析：ABD

-----------------------------------------------------------------------------------------------

16.下面代码下划线处可以填入哪个选项？

func main() {
    var s1 []int
    var s2 = []int{}
    if __ == nil {
        fmt.Println("yes nil")
    }else{
        fmt.Println("no nil")
    }
}
A. s1   B. s2   C. s1、s2 都可以

//解析：A  nil切片和nil相等，一般用来表示一个不存在的切片。空切片和nil不相等，表示一个空的集合。

-----------------------------------------------------------------------------------------------

17.下面这段代码输出什么？
func main() {
    i := 65
    fmt.Println(string(i))
}
A. A   B. 65  C. compilation error

//解析：A   UTF-8编码中，十进制数字65对应的符号是A

-----------------------------------------------------------------------------------------------

18.切片 a、b、c 的长度和容量分别是多少？
   func main() {
       s := [3]int{1, 2, 3}
       a := s[:0]
       b := s[:2]
       c := s[1:2:cap(s)]
   }

//解析：a、b、c 的长度和容量分别是 0 3、2 3、1 2。知识点：数组或切片的截取操作。
截取操作有带 2 个或者 3 个参数，形如：[i:j] 和 [i:j:k]，假设截取对象的底层数组长度为 l。
在操作符 [i:j] 中，如果 i 省略，默认 0，如果 j 省略，默认底层数组的长度，
截取得到的切片长度和容量计算方法是 j-i、l-i。操作符 [i:j:k]，k 主要是用来限制切片的容量，
但是不能大于数组的长度 l，截取得到的切片长度和容量计算方法是 j-i、k-i。


-----------------------------------------------------------------------------------------------

19.下面的两个切片声明中有什么区别？哪个更可取？

A. var a []int
B. a := []int{}

//解析：A 声明的是 nil 切片；B 声明的是长度和容量都为 0 的空切片。第一种切片声明不会分配内存，优先选择。

-----------------------------------------------------------------------------------------------

20. A、B、C、D 哪些选项有语法错误？

type S struct {
}

func f(x interface{}) {
}

func g(x *interface{}) {
}

func main() {
    s := S{}
    p := &s
    f(s) //A
    g(s) //B
    f(p) //C
    g(p) //D
}

//解析：BD。函数参数为 interface{} 时可以接收任何类型的参数，包括用户自定义类型等，即使是接收指针类型也用 interface{}，而不是使用 *interface{}。

     永远不要使用一个指针指向一个接口类型，因为它已经是一个指针。

-----------------------------------------------------------------------------------------------

21.下面 A、B 两处应该填入什么代码，才能确保顺利打印出结果？

type S struct {
    m string
}

func f() *S {
    return __  //A
}

func main() {
    p := __    //B
    fmt.Println(p.m) //print "foo"
}


//解析：
A. &S{"foo"}
B. *f() 或者 f()
f() 函数返回参数是指针类型，所以可以用 & 取结构体的指针；B 处，如果填 *f()，则 p 是 S 类型；如果填 f()，则 p 是 *S 类型，
不过都可以使用 p.m 取得结构体的成员。


-----------------------------------------------------------------------------------------------

22.下面这段代码输出什么？为什么？

func main() {

    s1 := []int{1, 2, 3}
    s2 := s1[1:]
    s2[1] = 4
    fmt.Println(s1)
    s2 = append(s2, 5, 6, 7)
    fmt.Println(s1)
}

//解析：
[1 2 4]
[1 2 4]
我们知道，golang 中切片底层的数据结构是数组。当使用 s1[1:] 获得切片 s2，和 s1 共享同一个底层数组，这会导致 s2[1] = 4 语句影响 s1。

而 append 操作会导致底层数组扩容，生成新的数组，因此追加数据后的 s2 不会影响 s1。

但是为什么对 s2 赋值后影响的却是 s1 的第三个元素呢？这是因为切片 s2 是从数组的第二个元素开始，s2 索引为 1 的元素对应的是 s1 索引为 2 的元素。


-----------------------------------------------------------------------------------------------

23.下面选项正确的是？

func main() {
    if a := 1; false {
    } else if b := 2; false {
    } else {
        println(a, b)
    }
}
A. 1 2

B. compilation error

解析： A

-----------------------------------------------------------------------------------------------


24.下面这段代码输出什么？为什么？

func (i int) PrintInt ()  {
    fmt.Println(i)
}

func main() {
    var i int = 1
    i.PrintInt()
}
A. 1

B. compilation error

解析：B。基于类型创建的方法必须定义在同一个包内，上面的代码基于 int 类型创建了 PrintInt() 方法，
由于 int 类型和方法 PrintInt() 定义在不同的包内，所以编译出错。

解决的办法可以定义一种新的类型：

type Myint int

func (i Myint) PrintInt ()  {
    fmt.Println(i)
}

func main() {
    var i Myint = 1
    i.PrintInt()
}

-----------------------------------------------------------------------------------------------

24.下面这段代码输出什么？为什么？

type People interface {
    Speak(string) string
}

type Student struct{}

func (stu *Student) Speak(think string) (talk string) {
    if think == "speak" {
        talk = "speak"
    } else {
        talk = "hi"
    }
    return
}

func main() {
    var peo People = Student{}
    think := "speak"
    fmt.Println(peo.Speak(think))
}
A. speak

B. compilation error

解析：B。编译错误 Student does not implement People (Speak method has pointer receiver)，
值类型 Student 没有实现接口的 Speak() 方法，而是指针类型 *Student 实现该方法。

-----------------------------------------------------------------------------------------------

25.下面这段代码能否正常结束？

func main() {
    v := []int{1, 2, 3}
    for i := range v {
        v = append(v, i)
    }
}

//解析：可以正常结束，循环次数在循环开始前已经确定，循环内改变切片长度，不会影响循环次数

-----------------------------------------------------------------------------------------------

26.下面这段代码输出什么？为什么？

func main() {
    var m = [...]int{1, 2, 3}
    for i, v := range m {
        go func() {
            fmt.Println(i, v)
        }()
    }
    time.Sleep(time.Second * 3)
}

//解析：
2 3
2 3
2 3
for range 使用短变量声明(:=)的形式迭代变量，需要注意的是，变量 i、v 在每次循环体中都会被重用，而不是重新声明。

各个 goroutine 中输出的 i、v 值都是 for range 循环结束后的 i、v 最终值，而不是各个goroutine启动时的i, v值。可以理解为闭包引用，使用的是上下文环境的值。

两种可行的 fix 方法:

1.使用函数传递

for i, v := range m {
    go func(i,v int) {
        fmt.Println(i, v)
    }(i,v)
}
2.使用临时变量保留当前值

for i, v := range m {
    i := i           // 这里的 := 会重新声明变量，而不是重用
    v := v
    go func() {
        fmt.Println(i, v)
    }()
}

-----------------------------------------------------------------------------------------------





